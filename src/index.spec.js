// Test data mostly from Wikipedia
// <https://en.wikipedia.org/w/index.php?title=Rounding&oldid=960109264#Comparison_of_approaches_for_rounding_to_an_integer>

const {
  divide,
  ROUNDING_MODE
} = require('.')

describe('divide', () => {
  describe('directed', () => {
    describe('towards zero', () => {
      it('works', () => {
        expect(divide(ROUNDING_MODE.DIRECTED_TOWARDS_ZERO, 18n, 10n)).toBe(1n)
        expect(divide(ROUNDING_MODE.DIRECTED_TOWARDS_ZERO, 15n, 10n)).toBe(1n)
        expect(divide(ROUNDING_MODE.DIRECTED_TOWARDS_ZERO, 12n, 10n)).toBe(1n)
        expect(divide(ROUNDING_MODE.DIRECTED_TOWARDS_ZERO, 10n, 10n)).toBe(1n)
        expect(divide(ROUNDING_MODE.DIRECTED_TOWARDS_ZERO, 8n, 10n)).toBe(0n)
        expect(divide(ROUNDING_MODE.DIRECTED_TOWARDS_ZERO, 5n, 10n)).toBe(0n)
        expect(divide(ROUNDING_MODE.DIRECTED_TOWARDS_ZERO, 2n, 10n)).toBe(0n)
        expect(divide(ROUNDING_MODE.DIRECTED_TOWARDS_ZERO, 0n, 10n)).toBe(0n)
        expect(divide(ROUNDING_MODE.DIRECTED_TOWARDS_ZERO, -2n, 10n)).toBe(0n)
        expect(divide(ROUNDING_MODE.DIRECTED_TOWARDS_ZERO, -5n, 10n)).toBe(0n)
        expect(divide(ROUNDING_MODE.DIRECTED_TOWARDS_ZERO, -8n, 10n)).toBe(0n)
        expect(divide(ROUNDING_MODE.DIRECTED_TOWARDS_ZERO, -10n, 10n)).toBe(-1n)
        expect(divide(ROUNDING_MODE.DIRECTED_TOWARDS_ZERO, -12n, 10n)).toBe(-1n)
        expect(divide(ROUNDING_MODE.DIRECTED_TOWARDS_ZERO, -15n, 10n)).toBe(-1n)
        expect(divide(ROUNDING_MODE.DIRECTED_TOWARDS_ZERO, -18n, 10n)).toBe(-1n)
      })

      it('works on negatives', () => {
        expect(divide(ROUNDING_MODE.DIRECTED_TOWARDS_ZERO, -18n, -10n)).toBe(1n)
        expect(divide(ROUNDING_MODE.DIRECTED_TOWARDS_ZERO, -15n, -10n)).toBe(1n)
        expect(divide(ROUNDING_MODE.DIRECTED_TOWARDS_ZERO, -12n, -10n)).toBe(1n)
        expect(divide(ROUNDING_MODE.DIRECTED_TOWARDS_ZERO, -10n, -10n)).toBe(1n)
        expect(divide(ROUNDING_MODE.DIRECTED_TOWARDS_ZERO, -8n, -10n)).toBe(0n)
        expect(divide(ROUNDING_MODE.DIRECTED_TOWARDS_ZERO, -5n, -10n)).toBe(0n)
        expect(divide(ROUNDING_MODE.DIRECTED_TOWARDS_ZERO, -2n, -10n)).toBe(0n)
        expect(divide(ROUNDING_MODE.DIRECTED_TOWARDS_ZERO, 0n, -10n)).toBe(0n)
        expect(divide(ROUNDING_MODE.DIRECTED_TOWARDS_ZERO, 2n, -10n)).toBe(0n)
        expect(divide(ROUNDING_MODE.DIRECTED_TOWARDS_ZERO, 5n, -10n)).toBe(0n)
        expect(divide(ROUNDING_MODE.DIRECTED_TOWARDS_ZERO, 8n, -10n)).toBe(0n)
        expect(divide(ROUNDING_MODE.DIRECTED_TOWARDS_ZERO, 10n, -10n)).toBe(-1n)
        expect(divide(ROUNDING_MODE.DIRECTED_TOWARDS_ZERO, 12n, -10n)).toBe(-1n)
        expect(divide(ROUNDING_MODE.DIRECTED_TOWARDS_ZERO, 15n, -10n)).toBe(-1n)
        expect(divide(ROUNDING_MODE.DIRECTED_TOWARDS_ZERO, 18n, -10n)).toBe(-1n)
      })
    })

    describe('away from zero', () => {
      it('works', () => {
        expect(divide(ROUNDING_MODE.DIRECTED_AWAY_FROM_ZERO, 18n, 10n)).toBe(2n)
        expect(divide(ROUNDING_MODE.DIRECTED_AWAY_FROM_ZERO, 15n, 10n)).toBe(2n)
        expect(divide(ROUNDING_MODE.DIRECTED_AWAY_FROM_ZERO, 12n, 10n)).toBe(2n)
        expect(divide(ROUNDING_MODE.DIRECTED_AWAY_FROM_ZERO, 10n, 10n)).toBe(1n)
        expect(divide(ROUNDING_MODE.DIRECTED_AWAY_FROM_ZERO, 8n, 10n)).toBe(1n)
        expect(divide(ROUNDING_MODE.DIRECTED_AWAY_FROM_ZERO, 5n, 10n)).toBe(1n)
        expect(divide(ROUNDING_MODE.DIRECTED_AWAY_FROM_ZERO, 2n, 10n)).toBe(1n)
        expect(divide(ROUNDING_MODE.DIRECTED_AWAY_FROM_ZERO, 0n, 10n)).toBe(0n)
        expect(divide(ROUNDING_MODE.DIRECTED_AWAY_FROM_ZERO, -2n, 10n)).toBe(-1n)
        expect(divide(ROUNDING_MODE.DIRECTED_AWAY_FROM_ZERO, -5n, 10n)).toBe(-1n)
        expect(divide(ROUNDING_MODE.DIRECTED_AWAY_FROM_ZERO, -8n, 10n)).toBe(-1n)
        expect(divide(ROUNDING_MODE.DIRECTED_AWAY_FROM_ZERO, -10n, 10n)).toBe(-1n)
        expect(divide(ROUNDING_MODE.DIRECTED_AWAY_FROM_ZERO, -12n, 10n)).toBe(-2n)
        expect(divide(ROUNDING_MODE.DIRECTED_AWAY_FROM_ZERO, -15n, 10n)).toBe(-2n)
        expect(divide(ROUNDING_MODE.DIRECTED_AWAY_FROM_ZERO, -18n, 10n)).toBe(-2n)
      })

      it('works', () => {
        expect(divide(ROUNDING_MODE.DIRECTED_AWAY_FROM_ZERO, 18n, 10n)).toBe(2n)
        expect(divide(ROUNDING_MODE.DIRECTED_AWAY_FROM_ZERO, 15n, 10n)).toBe(2n)
        expect(divide(ROUNDING_MODE.DIRECTED_AWAY_FROM_ZERO, 12n, 10n)).toBe(2n)
        expect(divide(ROUNDING_MODE.DIRECTED_AWAY_FROM_ZERO, 10n, 10n)).toBe(1n)
        expect(divide(ROUNDING_MODE.DIRECTED_AWAY_FROM_ZERO, 8n, 10n)).toBe(1n)
        expect(divide(ROUNDING_MODE.DIRECTED_AWAY_FROM_ZERO, 5n, 10n)).toBe(1n)
        expect(divide(ROUNDING_MODE.DIRECTED_AWAY_FROM_ZERO, 2n, 10n)).toBe(1n)
        expect(divide(ROUNDING_MODE.DIRECTED_AWAY_FROM_ZERO, 0n, 10n)).toBe(0n)
        expect(divide(ROUNDING_MODE.DIRECTED_AWAY_FROM_ZERO, -2n, 10n)).toBe(-1n)
        expect(divide(ROUNDING_MODE.DIRECTED_AWAY_FROM_ZERO, -5n, 10n)).toBe(-1n)
        expect(divide(ROUNDING_MODE.DIRECTED_AWAY_FROM_ZERO, -8n, 10n)).toBe(-1n)
        expect(divide(ROUNDING_MODE.DIRECTED_AWAY_FROM_ZERO, -10n, 10n)).toBe(-1n)
        expect(divide(ROUNDING_MODE.DIRECTED_AWAY_FROM_ZERO, -12n, 10n)).toBe(-2n)
        expect(divide(ROUNDING_MODE.DIRECTED_AWAY_FROM_ZERO, -15n, 10n)).toBe(-2n)
        expect(divide(ROUNDING_MODE.DIRECTED_AWAY_FROM_ZERO, -18n, 10n)).toBe(-2n)
      })
    })

    describe('towards negative infinity', () => {
      it('works', () => {
        expect(divide(ROUNDING_MODE.DIRECTED_TOWARDS_NEGATIVE_INFINITY, 18n, 10n)).toBe(1n)
        expect(divide(ROUNDING_MODE.DIRECTED_TOWARDS_NEGATIVE_INFINITY, 15n, 10n)).toBe(1n)
        expect(divide(ROUNDING_MODE.DIRECTED_TOWARDS_NEGATIVE_INFINITY, 12n, 10n)).toBe(1n)
        expect(divide(ROUNDING_MODE.DIRECTED_TOWARDS_NEGATIVE_INFINITY, 10n, 10n)).toBe(1n)
        expect(divide(ROUNDING_MODE.DIRECTED_TOWARDS_NEGATIVE_INFINITY, 8n, 10n)).toBe(0n)
        expect(divide(ROUNDING_MODE.DIRECTED_TOWARDS_NEGATIVE_INFINITY, 5n, 10n)).toBe(0n)
        expect(divide(ROUNDING_MODE.DIRECTED_TOWARDS_NEGATIVE_INFINITY, 2n, 10n)).toBe(0n)
        expect(divide(ROUNDING_MODE.DIRECTED_TOWARDS_NEGATIVE_INFINITY, 0n, 10n)).toBe(0n)
        expect(divide(ROUNDING_MODE.DIRECTED_TOWARDS_NEGATIVE_INFINITY, -2n, 10n)).toBe(-1n)
        expect(divide(ROUNDING_MODE.DIRECTED_TOWARDS_NEGATIVE_INFINITY, -5n, 10n)).toBe(-1n)
        expect(divide(ROUNDING_MODE.DIRECTED_TOWARDS_NEGATIVE_INFINITY, -8n, 10n)).toBe(-1n)
        expect(divide(ROUNDING_MODE.DIRECTED_TOWARDS_NEGATIVE_INFINITY, -10n, 10n)).toBe(-1n)
        expect(divide(ROUNDING_MODE.DIRECTED_TOWARDS_NEGATIVE_INFINITY, -12n, 10n)).toBe(-2n)
        expect(divide(ROUNDING_MODE.DIRECTED_TOWARDS_NEGATIVE_INFINITY, -15n, 10n)).toBe(-2n)
        expect(divide(ROUNDING_MODE.DIRECTED_TOWARDS_NEGATIVE_INFINITY, -18n, 10n)).toBe(-2n)
      })

      it('works on negatives', () => {
        expect(divide(ROUNDING_MODE.DIRECTED_TOWARDS_NEGATIVE_INFINITY, -18n, -10n)).toBe(1n)
        expect(divide(ROUNDING_MODE.DIRECTED_TOWARDS_NEGATIVE_INFINITY, -15n, -10n)).toBe(1n)
        expect(divide(ROUNDING_MODE.DIRECTED_TOWARDS_NEGATIVE_INFINITY, -12n, -10n)).toBe(1n)
        expect(divide(ROUNDING_MODE.DIRECTED_TOWARDS_NEGATIVE_INFINITY, -10n, -10n)).toBe(1n)
        expect(divide(ROUNDING_MODE.DIRECTED_TOWARDS_NEGATIVE_INFINITY, -8n, -10n)).toBe(0n)
        expect(divide(ROUNDING_MODE.DIRECTED_TOWARDS_NEGATIVE_INFINITY, -5n, -10n)).toBe(0n)
        expect(divide(ROUNDING_MODE.DIRECTED_TOWARDS_NEGATIVE_INFINITY, -2n, -10n)).toBe(0n)
        expect(divide(ROUNDING_MODE.DIRECTED_TOWARDS_NEGATIVE_INFINITY, 0n, -10n)).toBe(0n)
        expect(divide(ROUNDING_MODE.DIRECTED_TOWARDS_NEGATIVE_INFINITY, 2n, -10n)).toBe(-1n)
        expect(divide(ROUNDING_MODE.DIRECTED_TOWARDS_NEGATIVE_INFINITY, 5n, -10n)).toBe(-1n)
        expect(divide(ROUNDING_MODE.DIRECTED_TOWARDS_NEGATIVE_INFINITY, 8n, -10n)).toBe(-1n)
        expect(divide(ROUNDING_MODE.DIRECTED_TOWARDS_NEGATIVE_INFINITY, 10n, -10n)).toBe(-1n)
        expect(divide(ROUNDING_MODE.DIRECTED_TOWARDS_NEGATIVE_INFINITY, 12n, -10n)).toBe(-2n)
        expect(divide(ROUNDING_MODE.DIRECTED_TOWARDS_NEGATIVE_INFINITY, 15n, -10n)).toBe(-2n)
        expect(divide(ROUNDING_MODE.DIRECTED_TOWARDS_NEGATIVE_INFINITY, 18n, -10n)).toBe(-2n)
      })
    })

    describe('towards positive infinity', () => {
      it('works', () => {
        expect(divide(ROUNDING_MODE.DIRECTED_TOWARDS_POSITIVE_INFINITY, 18n, 10n)).toBe(2n)
        expect(divide(ROUNDING_MODE.DIRECTED_TOWARDS_POSITIVE_INFINITY, 15n, 10n)).toBe(2n)
        expect(divide(ROUNDING_MODE.DIRECTED_TOWARDS_POSITIVE_INFINITY, 12n, 10n)).toBe(2n)
        expect(divide(ROUNDING_MODE.DIRECTED_TOWARDS_POSITIVE_INFINITY, 10n, 10n)).toBe(1n)
        expect(divide(ROUNDING_MODE.DIRECTED_TOWARDS_POSITIVE_INFINITY, 8n, 10n)).toBe(1n)
        expect(divide(ROUNDING_MODE.DIRECTED_TOWARDS_POSITIVE_INFINITY, 5n, 10n)).toBe(1n)
        expect(divide(ROUNDING_MODE.DIRECTED_TOWARDS_POSITIVE_INFINITY, 2n, 10n)).toBe(1n)
        expect(divide(ROUNDING_MODE.DIRECTED_TOWARDS_POSITIVE_INFINITY, 0n, 10n)).toBe(0n)
        expect(divide(ROUNDING_MODE.DIRECTED_TOWARDS_POSITIVE_INFINITY, -2n, 10n)).toBe(0n)
        expect(divide(ROUNDING_MODE.DIRECTED_TOWARDS_POSITIVE_INFINITY, -5n, 10n)).toBe(0n)
        expect(divide(ROUNDING_MODE.DIRECTED_TOWARDS_POSITIVE_INFINITY, -8n, 10n)).toBe(0n)
        expect(divide(ROUNDING_MODE.DIRECTED_TOWARDS_POSITIVE_INFINITY, -10n, 10n)).toBe(-1n)
        expect(divide(ROUNDING_MODE.DIRECTED_TOWARDS_POSITIVE_INFINITY, -12n, 10n)).toBe(-1n)
        expect(divide(ROUNDING_MODE.DIRECTED_TOWARDS_POSITIVE_INFINITY, -15n, 10n)).toBe(-1n)
        expect(divide(ROUNDING_MODE.DIRECTED_TOWARDS_POSITIVE_INFINITY, -18n, 10n)).toBe(-1n)
      })

      it('works on negatives', () => {
        expect(divide(ROUNDING_MODE.DIRECTED_TOWARDS_POSITIVE_INFINITY, -18n, -10n)).toBe(2n)
        expect(divide(ROUNDING_MODE.DIRECTED_TOWARDS_POSITIVE_INFINITY, -15n, -10n)).toBe(2n)
        expect(divide(ROUNDING_MODE.DIRECTED_TOWARDS_POSITIVE_INFINITY, -12n, -10n)).toBe(2n)
        expect(divide(ROUNDING_MODE.DIRECTED_TOWARDS_POSITIVE_INFINITY, -10n, -10n)).toBe(1n)
        expect(divide(ROUNDING_MODE.DIRECTED_TOWARDS_POSITIVE_INFINITY, -8n, -10n)).toBe(1n)
        expect(divide(ROUNDING_MODE.DIRECTED_TOWARDS_POSITIVE_INFINITY, -5n, -10n)).toBe(1n)
        expect(divide(ROUNDING_MODE.DIRECTED_TOWARDS_POSITIVE_INFINITY, -2n, -10n)).toBe(1n)
        expect(divide(ROUNDING_MODE.DIRECTED_TOWARDS_POSITIVE_INFINITY, 0n, -10n)).toBe(0n)
        expect(divide(ROUNDING_MODE.DIRECTED_TOWARDS_POSITIVE_INFINITY, 2n, -10n)).toBe(0n)
        expect(divide(ROUNDING_MODE.DIRECTED_TOWARDS_POSITIVE_INFINITY, 5n, -10n)).toBe(0n)
        expect(divide(ROUNDING_MODE.DIRECTED_TOWARDS_POSITIVE_INFINITY, 8n, -10n)).toBe(0n)
        expect(divide(ROUNDING_MODE.DIRECTED_TOWARDS_POSITIVE_INFINITY, 10n, -10n)).toBe(-1n)
        expect(divide(ROUNDING_MODE.DIRECTED_TOWARDS_POSITIVE_INFINITY, 12n, -10n)).toBe(-1n)
        expect(divide(ROUNDING_MODE.DIRECTED_TOWARDS_POSITIVE_INFINITY, 15n, -10n)).toBe(-1n)
        expect(divide(ROUNDING_MODE.DIRECTED_TOWARDS_POSITIVE_INFINITY, 18n, -10n)).toBe(-1n)
      })
    })
  })

  describe('to nearest', () => {
    describe('half towards zero', () => {
      it('works', () => {
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TOWARDS_ZERO, 18n, 10n)).toBe(2n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TOWARDS_ZERO, 15n, 10n)).toBe(1n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TOWARDS_ZERO, 12n, 10n)).toBe(1n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TOWARDS_ZERO, 10n, 10n)).toBe(1n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TOWARDS_ZERO, 8n, 10n)).toBe(1n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TOWARDS_ZERO, 5n, 10n)).toBe(0n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TOWARDS_ZERO, 2n, 10n)).toBe(0n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TOWARDS_ZERO, 0n, 10n)).toBe(0n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TOWARDS_ZERO, -2n, 10n)).toBe(0n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TOWARDS_ZERO, -5n, 10n)).toBe(0n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TOWARDS_ZERO, -8n, 10n)).toBe(-1n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TOWARDS_ZERO, -10n, 10n)).toBe(-1n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TOWARDS_ZERO, -12n, 10n)).toBe(-1n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TOWARDS_ZERO, -15n, 10n)).toBe(-1n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TOWARDS_ZERO, -18n, 10n)).toBe(-2n)
      })

      it('works on negatives', () => {
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TOWARDS_ZERO, -18n, -10n)).toBe(2n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TOWARDS_ZERO, -15n, -10n)).toBe(1n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TOWARDS_ZERO, -12n, -10n)).toBe(1n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TOWARDS_ZERO, -10n, -10n)).toBe(1n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TOWARDS_ZERO, -8n, -10n)).toBe(1n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TOWARDS_ZERO, -5n, -10n)).toBe(0n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TOWARDS_ZERO, -2n, -10n)).toBe(0n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TOWARDS_ZERO, 0n, -10n)).toBe(0n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TOWARDS_ZERO, 2n, -10n)).toBe(0n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TOWARDS_ZERO, 5n, -10n)).toBe(0n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TOWARDS_ZERO, 8n, -10n)).toBe(-1n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TOWARDS_ZERO, 10n, -10n)).toBe(-1n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TOWARDS_ZERO, 12n, -10n)).toBe(-1n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TOWARDS_ZERO, 15n, -10n)).toBe(-1n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TOWARDS_ZERO, 18n, -10n)).toBe(-2n)
      })
    })

    describe('half away from zero', () => {
      it('works', () => {
        expect(divide(ROUNDING_MODE.NEAREST_HALF_AWAY_FROM_ZERO, 18n, 10n)).toBe(2n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_AWAY_FROM_ZERO, 15n, 10n)).toBe(2n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_AWAY_FROM_ZERO, 12n, 10n)).toBe(1n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_AWAY_FROM_ZERO, 10n, 10n)).toBe(1n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_AWAY_FROM_ZERO, 8n, 10n)).toBe(1n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_AWAY_FROM_ZERO, 5n, 10n)).toBe(1n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_AWAY_FROM_ZERO, 2n, 10n)).toBe(0n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_AWAY_FROM_ZERO, 0n, 10n)).toBe(0n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_AWAY_FROM_ZERO, -2n, 10n)).toBe(0n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_AWAY_FROM_ZERO, -5n, 10n)).toBe(-1n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_AWAY_FROM_ZERO, -8n, 10n)).toBe(-1n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_AWAY_FROM_ZERO, -10n, 10n)).toBe(-1n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_AWAY_FROM_ZERO, -12n, 10n)).toBe(-1n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_AWAY_FROM_ZERO, -15n, 10n)).toBe(-2n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_AWAY_FROM_ZERO, -18n, 10n)).toBe(-2n)
      })

      it('works on negatives', () => {
        expect(divide(ROUNDING_MODE.NEAREST_HALF_AWAY_FROM_ZERO, -18n, -10n)).toBe(2n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_AWAY_FROM_ZERO, -15n, -10n)).toBe(2n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_AWAY_FROM_ZERO, -12n, -10n)).toBe(1n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_AWAY_FROM_ZERO, -10n, -10n)).toBe(1n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_AWAY_FROM_ZERO, -8n, -10n)).toBe(1n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_AWAY_FROM_ZERO, -5n, -10n)).toBe(1n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_AWAY_FROM_ZERO, -2n, -10n)).toBe(0n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_AWAY_FROM_ZERO, 0n, -10n)).toBe(0n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_AWAY_FROM_ZERO, 2n, -10n)).toBe(0n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_AWAY_FROM_ZERO, 5n, -10n)).toBe(-1n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_AWAY_FROM_ZERO, 8n, -10n)).toBe(-1n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_AWAY_FROM_ZERO, 10n, -10n)).toBe(-1n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_AWAY_FROM_ZERO, 12n, -10n)).toBe(-1n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_AWAY_FROM_ZERO, 15n, -10n)).toBe(-2n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_AWAY_FROM_ZERO, 18n, -10n)).toBe(-2n)
      })
    })

    describe('half towards negative infinity', () => {
      it('works', () => {
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TOWARDS_NEGATIVE_INFINITY, 18n, 10n)).toBe(2n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TOWARDS_NEGATIVE_INFINITY, 15n, 10n)).toBe(1n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TOWARDS_NEGATIVE_INFINITY, 12n, 10n)).toBe(1n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TOWARDS_NEGATIVE_INFINITY, 10n, 10n)).toBe(1n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TOWARDS_NEGATIVE_INFINITY, 8n, 10n)).toBe(1n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TOWARDS_NEGATIVE_INFINITY, 5n, 10n)).toBe(0n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TOWARDS_NEGATIVE_INFINITY, 2n, 10n)).toBe(0n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TOWARDS_NEGATIVE_INFINITY, 0n, 10n)).toBe(0n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TOWARDS_NEGATIVE_INFINITY, -2n, 10n)).toBe(0n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TOWARDS_NEGATIVE_INFINITY, -5n, 10n)).toBe(-1n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TOWARDS_NEGATIVE_INFINITY, -8n, 10n)).toBe(-1n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TOWARDS_NEGATIVE_INFINITY, -10n, 10n)).toBe(-1n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TOWARDS_NEGATIVE_INFINITY, -12n, 10n)).toBe(-1n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TOWARDS_NEGATIVE_INFINITY, -15n, 10n)).toBe(-2n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TOWARDS_NEGATIVE_INFINITY, -18n, 10n)).toBe(-2n)
      })

      it('works on negatives', () => {
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TOWARDS_NEGATIVE_INFINITY, -18n, -10n)).toBe(2n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TOWARDS_NEGATIVE_INFINITY, -15n, -10n)).toBe(1n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TOWARDS_NEGATIVE_INFINITY, -12n, -10n)).toBe(1n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TOWARDS_NEGATIVE_INFINITY, -10n, -10n)).toBe(1n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TOWARDS_NEGATIVE_INFINITY, -8n, -10n)).toBe(1n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TOWARDS_NEGATIVE_INFINITY, -5n, -10n)).toBe(0n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TOWARDS_NEGATIVE_INFINITY, -2n, -10n)).toBe(0n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TOWARDS_NEGATIVE_INFINITY, 0n, -10n)).toBe(0n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TOWARDS_NEGATIVE_INFINITY, 2n, -10n)).toBe(0n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TOWARDS_NEGATIVE_INFINITY, 5n, -10n)).toBe(-1n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TOWARDS_NEGATIVE_INFINITY, 8n, -10n)).toBe(-1n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TOWARDS_NEGATIVE_INFINITY, 10n, -10n)).toBe(-1n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TOWARDS_NEGATIVE_INFINITY, 12n, -10n)).toBe(-1n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TOWARDS_NEGATIVE_INFINITY, 15n, -10n)).toBe(-2n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TOWARDS_NEGATIVE_INFINITY, 18n, -10n)).toBe(-2n)
      })
    })

    describe('half towards positive infinity', () => {
      it('works', () => {
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TOWARDS_POSITIVE_INFINITY, 18n, 10n)).toBe(2n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TOWARDS_POSITIVE_INFINITY, 15n, 10n)).toBe(2n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TOWARDS_POSITIVE_INFINITY, 12n, 10n)).toBe(1n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TOWARDS_POSITIVE_INFINITY, 10n, 10n)).toBe(1n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TOWARDS_POSITIVE_INFINITY, 8n, 10n)).toBe(1n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TOWARDS_POSITIVE_INFINITY, 5n, 10n)).toBe(1n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TOWARDS_POSITIVE_INFINITY, 2n, 10n)).toBe(0n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TOWARDS_POSITIVE_INFINITY, 0n, 10n)).toBe(0n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TOWARDS_POSITIVE_INFINITY, -2n, 10n)).toBe(0n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TOWARDS_POSITIVE_INFINITY, -5n, 10n)).toBe(0n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TOWARDS_POSITIVE_INFINITY, -8n, 10n)).toBe(-1n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TOWARDS_POSITIVE_INFINITY, -10n, 10n)).toBe(-1n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TOWARDS_POSITIVE_INFINITY, -12n, 10n)).toBe(-1n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TOWARDS_POSITIVE_INFINITY, -15n, 10n)).toBe(-1n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TOWARDS_POSITIVE_INFINITY, -18n, 10n)).toBe(-2n)
      })

      it('works on negatives', () => {
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TOWARDS_POSITIVE_INFINITY, -18n, -10n)).toBe(2n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TOWARDS_POSITIVE_INFINITY, -15n, -10n)).toBe(2n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TOWARDS_POSITIVE_INFINITY, -12n, -10n)).toBe(1n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TOWARDS_POSITIVE_INFINITY, -10n, -10n)).toBe(1n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TOWARDS_POSITIVE_INFINITY, -8n, -10n)).toBe(1n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TOWARDS_POSITIVE_INFINITY, -5n, -10n)).toBe(1n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TOWARDS_POSITIVE_INFINITY, -2n, -10n)).toBe(0n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TOWARDS_POSITIVE_INFINITY, 0n, -10n)).toBe(0n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TOWARDS_POSITIVE_INFINITY, 2n, -10n)).toBe(0n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TOWARDS_POSITIVE_INFINITY, 5n, -10n)).toBe(0n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TOWARDS_POSITIVE_INFINITY, 8n, -10n)).toBe(-1n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TOWARDS_POSITIVE_INFINITY, 10n, -10n)).toBe(-1n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TOWARDS_POSITIVE_INFINITY, 12n, -10n)).toBe(-1n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TOWARDS_POSITIVE_INFINITY, 15n, -10n)).toBe(-1n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TOWARDS_POSITIVE_INFINITY, 18n, -10n)).toBe(-2n)
      })
    })

    describe('half to even', () => {
      it('works', () => {
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TO_EVEN, 18n, 10n)).toBe(2n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TO_EVEN, 15n, 10n)).toBe(2n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TO_EVEN, 12n, 10n)).toBe(1n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TO_EVEN, 10n, 10n)).toBe(1n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TO_EVEN, 8n, 10n)).toBe(1n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TO_EVEN, 5n, 10n)).toBe(0n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TO_EVEN, 2n, 10n)).toBe(0n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TO_EVEN, 0n, 10n)).toBe(0n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TO_EVEN, -2n, 10n)).toBe(0n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TO_EVEN, -5n, 10n)).toBe(0n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TO_EVEN, -8n, 10n)).toBe(-1n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TO_EVEN, -10n, 10n)).toBe(-1n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TO_EVEN, -12n, 10n)).toBe(-1n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TO_EVEN, -15n, 10n)).toBe(-2n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TO_EVEN, -18n, 10n)).toBe(-2n)
      })

      it('works on negatives', () => {
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TO_EVEN, -18n, -10n)).toBe(2n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TO_EVEN, -15n, -10n)).toBe(2n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TO_EVEN, -12n, -10n)).toBe(1n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TO_EVEN, -10n, -10n)).toBe(1n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TO_EVEN, -8n, -10n)).toBe(1n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TO_EVEN, -5n, -10n)).toBe(0n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TO_EVEN, -2n, -10n)).toBe(0n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TO_EVEN, 0n, -10n)).toBe(0n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TO_EVEN, 2n, -10n)).toBe(0n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TO_EVEN, 5n, -10n)).toBe(0n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TO_EVEN, 8n, -10n)).toBe(-1n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TO_EVEN, 10n, -10n)).toBe(-1n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TO_EVEN, 12n, -10n)).toBe(-1n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TO_EVEN, 15n, -10n)).toBe(-2n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TO_EVEN, 18n, -10n)).toBe(-2n)
      })
    })

    describe('half to odd', () => {
      it('works', () => {
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TO_ODD, 18n, 10n)).toBe(2n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TO_ODD, 15n, 10n)).toBe(1n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TO_ODD, 12n, 10n)).toBe(1n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TO_ODD, 10n, 10n)).toBe(1n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TO_ODD, 8n, 10n)).toBe(1n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TO_ODD, 5n, 10n)).toBe(1n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TO_ODD, 2n, 10n)).toBe(0n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TO_ODD, 0n, 10n)).toBe(0n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TO_ODD, -2n, 10n)).toBe(0n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TO_ODD, -5n, 10n)).toBe(-1n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TO_ODD, -8n, 10n)).toBe(-1n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TO_ODD, -10n, 10n)).toBe(-1n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TO_ODD, -12n, 10n)).toBe(-1n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TO_ODD, -15n, 10n)).toBe(-1n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TO_ODD, -18n, 10n)).toBe(-2n)
      })

      it('works on negatives', () => {
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TO_ODD, -18n, -10n)).toBe(2n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TO_ODD, -15n, -10n)).toBe(1n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TO_ODD, -12n, -10n)).toBe(1n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TO_ODD, -10n, -10n)).toBe(1n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TO_ODD, -8n, -10n)).toBe(1n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TO_ODD, -5n, -10n)).toBe(1n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TO_ODD, -2n, -10n)).toBe(0n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TO_ODD, 0n, -10n)).toBe(0n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TO_ODD, 2n, -10n)).toBe(0n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TO_ODD, 5n, -10n)).toBe(-1n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TO_ODD, 8n, -10n)).toBe(-1n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TO_ODD, 10n, -10n)).toBe(-1n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TO_ODD, 12n, -10n)).toBe(-1n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TO_ODD, 15n, -10n)).toBe(-1n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TO_ODD, 18n, -10n)).toBe(-2n)
      })
    })
  })
})
