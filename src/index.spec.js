/* eslint-env jest */

// Test data mostly from Wikipedia
// <https://en.wikipedia.org/w/index.php?title=Rounding&oldid=960109264#Comparison_of_approaches_for_rounding_to_an_integer>

const {
  divide,
  ROUNDING_MODE
} = require('.')

describe('divide', () => {
  describe('unrecognised', () => {
    it('throws', () => {
      expect(() => divide(-50103, 18n, 10n)).toThrowError()
      expect(() => divide(-50103, 15n, 10n)).toThrowError()
      expect(() => divide(-50103, 12n, 10n)).toThrowError()
      expect(() => divide(-50103, 10n, 10n)).toThrowError()
      expect(() => divide(-50103, 8n, 10n)).toThrowError()
      expect(() => divide(-50103, 5n, 10n)).toThrowError()
      expect(() => divide(-50103, 2n, 10n)).toThrowError()
      expect(() => divide(-50103, 0n, 10n)).toThrowError()
      expect(() => divide(-50103, -2n, 10n)).toThrowError()
      expect(() => divide(-50103, -5n, 10n)).toThrowError()
      expect(() => divide(-50103, -8n, 10n)).toThrowError()
      expect(() => divide(-50103, -10n, 10n)).toThrowError()
      expect(() => divide(-50103, -12n, 10n)).toThrowError()
      expect(() => divide(-50103, -15n, 10n)).toThrowError()
      expect(() => divide(-50103, -18n, 10n)).toThrowError()
    })

    it('throws on negatives', () => {
      expect(() => divide(-50103, -18n, -10n)).toThrowError()
      expect(() => divide(-50103, -15n, -10n)).toThrowError()
      expect(() => divide(-50103, -12n, -10n)).toThrowError()
      expect(() => divide(-50103, -10n, -10n)).toThrowError()
      expect(() => divide(-50103, -8n, -10n)).toThrowError()
      expect(() => divide(-50103, -5n, -10n)).toThrowError()
      expect(() => divide(-50103, -2n, -10n)).toThrowError()
      expect(() => divide(-50103, 0n, -10n)).toThrowError()
      expect(() => divide(-50103, 2n, -10n)).toThrowError()
      expect(() => divide(-50103, 5n, -10n)).toThrowError()
      expect(() => divide(-50103, 8n, -10n)).toThrowError()
      expect(() => divide(-50103, 10n, -10n)).toThrowError()
      expect(() => divide(-50103, 12n, -10n)).toThrowError()
      expect(() => divide(-50103, 15n, -10n)).toThrowError()
      expect(() => divide(-50103, 18n, -10n)).toThrowError()
    })
  })

  describe('directed', () => {
    describe('throw', () => {
      it('works', () => {
        expect(() => divide(ROUNDING_MODE.THROW, 18n, 10n)).toThrowError()
        expect(() => divide(ROUNDING_MODE.THROW, 15n, 10n)).toThrowError()
        expect(() => divide(ROUNDING_MODE.THROW, 12n, 10n)).toThrowError()
        expect(divide(ROUNDING_MODE.THROW, 10n, 10n)).toBe(1n)
        expect(() => divide(ROUNDING_MODE.THROW, 8n, 10n)).toThrowError()
        expect(() => divide(ROUNDING_MODE.THROW, 5n, 10n)).toThrowError()
        expect(() => divide(ROUNDING_MODE.THROW, 2n, 10n)).toThrowError()
        expect(divide(ROUNDING_MODE.THROW, 0n, 10n)).toBe(0n)
        expect(() => divide(ROUNDING_MODE.THROW, -2n, 10n)).toThrowError()
        expect(() => divide(ROUNDING_MODE.THROW, -5n, 10n)).toThrowError()
        expect(() => divide(ROUNDING_MODE.THROW, -8n, 10n)).toThrowError()
        expect(divide(ROUNDING_MODE.THROW, -10n, 10n)).toBe(-1n)
        expect(() => divide(ROUNDING_MODE.THROW, -12n, 10n)).toThrowError()
        expect(() => divide(ROUNDING_MODE.THROW, -15n, 10n)).toThrowError()
        expect(() => divide(ROUNDING_MODE.THROW, -18n, 10n)).toThrowError()
      })

      it('works on negatives', () => {
        expect(() => divide(ROUNDING_MODE.THROW, -18n, -10n)).toThrowError()
        expect(() => divide(ROUNDING_MODE.THROW, -15n, -10n)).toThrowError()
        expect(() => divide(ROUNDING_MODE.THROW, -12n, -10n)).toThrowError()
        expect(divide(ROUNDING_MODE.THROW, -10n, -10n)).toBe(1n)
        expect(() => divide(ROUNDING_MODE.THROW, -8n, -10n)).toThrowError()
        expect(() => divide(ROUNDING_MODE.THROW, -5n, -10n)).toThrowError()
        expect(() => divide(ROUNDING_MODE.THROW, -2n, -10n)).toThrowError()
        expect(divide(ROUNDING_MODE.THROW, 0n, -10n)).toBe(0n)
        expect(() => divide(ROUNDING_MODE.THROW, 2n, -10n)).toThrowError()
        expect(() => divide(ROUNDING_MODE.THROW, 5n, -10n)).toThrowError()
        expect(() => divide(ROUNDING_MODE.THROW, 8n, -10n)).toThrowError()
        expect(divide(ROUNDING_MODE.THROW, 10n, -10n)).toBe(-1n)
        expect(() => divide(ROUNDING_MODE.THROW, 12n, -10n)).toThrowError()
        expect(() => divide(ROUNDING_MODE.THROW, 15n, -10n)).toThrowError()
        expect(() => divide(ROUNDING_MODE.THROW, 18n, -10n)).toThrowError()
      })
    })

    describe('towards zero', () => {
      it('works', () => {
        expect(divide(ROUNDING_MODE.DIRECTED_TOWARDS_ZERO, 18n, 10n)).toBe(1n)
        expect(divide(ROUNDING_MODE.DIRECTED_TOWARDS_ZERO, 15n, 10n)).toBe(1n)
        expect(divide(ROUNDING_MODE.DIRECTED_TOWARDS_ZERO, 12n, 10n)).toBe(1n)
        expect(divide(ROUNDING_MODE.DIRECTED_TOWARDS_ZERO, 10n, 10n)).toBe(1n)
        expect(divide(ROUNDING_MODE.DIRECTED_TOWARDS_ZERO, 8n, 10n)).toBe(0n)
        expect(divide(ROUNDING_MODE.DIRECTED_TOWARDS_ZERO, 5n, 10n)).toBe(0n)
        expect(divide(ROUNDING_MODE.DIRECTED_TOWARDS_ZERO, 2n, 10n)).toBe(0n)
        expect(divide(ROUNDING_MODE.DIRECTED_TOWARDS_ZERO, 0n, 10n)).toBe(0n)
        expect(divide(ROUNDING_MODE.DIRECTED_TOWARDS_ZERO, -2n, 10n)).toBe(0n)
        expect(divide(ROUNDING_MODE.DIRECTED_TOWARDS_ZERO, -5n, 10n)).toBe(0n)
        expect(divide(ROUNDING_MODE.DIRECTED_TOWARDS_ZERO, -8n, 10n)).toBe(0n)
        expect(divide(ROUNDING_MODE.DIRECTED_TOWARDS_ZERO, -10n, 10n)).toBe(-1n)
        expect(divide(ROUNDING_MODE.DIRECTED_TOWARDS_ZERO, -12n, 10n)).toBe(-1n)
        expect(divide(ROUNDING_MODE.DIRECTED_TOWARDS_ZERO, -15n, 10n)).toBe(-1n)
        expect(divide(ROUNDING_MODE.DIRECTED_TOWARDS_ZERO, -18n, 10n)).toBe(-1n)
      })

      it('works on negatives', () => {
        expect(divide(ROUNDING_MODE.DIRECTED_TOWARDS_ZERO, -18n, -10n)).toBe(1n)
        expect(divide(ROUNDING_MODE.DIRECTED_TOWARDS_ZERO, -15n, -10n)).toBe(1n)
        expect(divide(ROUNDING_MODE.DIRECTED_TOWARDS_ZERO, -12n, -10n)).toBe(1n)
        expect(divide(ROUNDING_MODE.DIRECTED_TOWARDS_ZERO, -10n, -10n)).toBe(1n)
        expect(divide(ROUNDING_MODE.DIRECTED_TOWARDS_ZERO, -8n, -10n)).toBe(0n)
        expect(divide(ROUNDING_MODE.DIRECTED_TOWARDS_ZERO, -5n, -10n)).toBe(0n)
        expect(divide(ROUNDING_MODE.DIRECTED_TOWARDS_ZERO, -2n, -10n)).toBe(0n)
        expect(divide(ROUNDING_MODE.DIRECTED_TOWARDS_ZERO, 0n, -10n)).toBe(0n)
        expect(divide(ROUNDING_MODE.DIRECTED_TOWARDS_ZERO, 2n, -10n)).toBe(0n)
        expect(divide(ROUNDING_MODE.DIRECTED_TOWARDS_ZERO, 5n, -10n)).toBe(0n)
        expect(divide(ROUNDING_MODE.DIRECTED_TOWARDS_ZERO, 8n, -10n)).toBe(0n)
        expect(divide(ROUNDING_MODE.DIRECTED_TOWARDS_ZERO, 10n, -10n)).toBe(-1n)
        expect(divide(ROUNDING_MODE.DIRECTED_TOWARDS_ZERO, 12n, -10n)).toBe(-1n)
        expect(divide(ROUNDING_MODE.DIRECTED_TOWARDS_ZERO, 15n, -10n)).toBe(-1n)
        expect(divide(ROUNDING_MODE.DIRECTED_TOWARDS_ZERO, 18n, -10n)).toBe(-1n)
      })
    })

    describe('away from zero', () => {
      it('works', () => {
        expect(divide(ROUNDING_MODE.DIRECTED_AWAY_FROM_ZERO, 18n, 10n)).toBe(2n)
        expect(divide(ROUNDING_MODE.DIRECTED_AWAY_FROM_ZERO, 15n, 10n)).toBe(2n)
        expect(divide(ROUNDING_MODE.DIRECTED_AWAY_FROM_ZERO, 12n, 10n)).toBe(2n)
        expect(divide(ROUNDING_MODE.DIRECTED_AWAY_FROM_ZERO, 10n, 10n)).toBe(1n)
        expect(divide(ROUNDING_MODE.DIRECTED_AWAY_FROM_ZERO, 8n, 10n)).toBe(1n)
        expect(divide(ROUNDING_MODE.DIRECTED_AWAY_FROM_ZERO, 5n, 10n)).toBe(1n)
        expect(divide(ROUNDING_MODE.DIRECTED_AWAY_FROM_ZERO, 2n, 10n)).toBe(1n)
        expect(divide(ROUNDING_MODE.DIRECTED_AWAY_FROM_ZERO, 0n, 10n)).toBe(0n)
        expect(divide(ROUNDING_MODE.DIRECTED_AWAY_FROM_ZERO, -2n, 10n)).toBe(-1n)
        expect(divide(ROUNDING_MODE.DIRECTED_AWAY_FROM_ZERO, -5n, 10n)).toBe(-1n)
        expect(divide(ROUNDING_MODE.DIRECTED_AWAY_FROM_ZERO, -8n, 10n)).toBe(-1n)
        expect(divide(ROUNDING_MODE.DIRECTED_AWAY_FROM_ZERO, -10n, 10n)).toBe(-1n)
        expect(divide(ROUNDING_MODE.DIRECTED_AWAY_FROM_ZERO, -12n, 10n)).toBe(-2n)
        expect(divide(ROUNDING_MODE.DIRECTED_AWAY_FROM_ZERO, -15n, 10n)).toBe(-2n)
        expect(divide(ROUNDING_MODE.DIRECTED_AWAY_FROM_ZERO, -18n, 10n)).toBe(-2n)
      })

      it('works on negatives', () => {
        expect(divide(ROUNDING_MODE.DIRECTED_AWAY_FROM_ZERO, 18n, 10n)).toBe(2n)
        expect(divide(ROUNDING_MODE.DIRECTED_AWAY_FROM_ZERO, 15n, 10n)).toBe(2n)
        expect(divide(ROUNDING_MODE.DIRECTED_AWAY_FROM_ZERO, 12n, 10n)).toBe(2n)
        expect(divide(ROUNDING_MODE.DIRECTED_AWAY_FROM_ZERO, 10n, 10n)).toBe(1n)
        expect(divide(ROUNDING_MODE.DIRECTED_AWAY_FROM_ZERO, 8n, 10n)).toBe(1n)
        expect(divide(ROUNDING_MODE.DIRECTED_AWAY_FROM_ZERO, 5n, 10n)).toBe(1n)
        expect(divide(ROUNDING_MODE.DIRECTED_AWAY_FROM_ZERO, 2n, 10n)).toBe(1n)
        expect(divide(ROUNDING_MODE.DIRECTED_AWAY_FROM_ZERO, 0n, 10n)).toBe(0n)
        expect(divide(ROUNDING_MODE.DIRECTED_AWAY_FROM_ZERO, -2n, 10n)).toBe(-1n)
        expect(divide(ROUNDING_MODE.DIRECTED_AWAY_FROM_ZERO, -5n, 10n)).toBe(-1n)
        expect(divide(ROUNDING_MODE.DIRECTED_AWAY_FROM_ZERO, -8n, 10n)).toBe(-1n)
        expect(divide(ROUNDING_MODE.DIRECTED_AWAY_FROM_ZERO, -10n, 10n)).toBe(-1n)
        expect(divide(ROUNDING_MODE.DIRECTED_AWAY_FROM_ZERO, -12n, 10n)).toBe(-2n)
        expect(divide(ROUNDING_MODE.DIRECTED_AWAY_FROM_ZERO, -15n, 10n)).toBe(-2n)
        expect(divide(ROUNDING_MODE.DIRECTED_AWAY_FROM_ZERO, -18n, 10n)).toBe(-2n)
      })
    })

    describe('towards negative infinity', () => {
      it('works', () => {
        expect(divide(ROUNDING_MODE.DIRECTED_TOWARDS_NEGATIVE_INFINITY, 18n, 10n)).toBe(1n)
        expect(divide(ROUNDING_MODE.DIRECTED_TOWARDS_NEGATIVE_INFINITY, 15n, 10n)).toBe(1n)
        expect(divide(ROUNDING_MODE.DIRECTED_TOWARDS_NEGATIVE_INFINITY, 12n, 10n)).toBe(1n)
        expect(divide(ROUNDING_MODE.DIRECTED_TOWARDS_NEGATIVE_INFINITY, 10n, 10n)).toBe(1n)
        expect(divide(ROUNDING_MODE.DIRECTED_TOWARDS_NEGATIVE_INFINITY, 8n, 10n)).toBe(0n)
        expect(divide(ROUNDING_MODE.DIRECTED_TOWARDS_NEGATIVE_INFINITY, 5n, 10n)).toBe(0n)
        expect(divide(ROUNDING_MODE.DIRECTED_TOWARDS_NEGATIVE_INFINITY, 2n, 10n)).toBe(0n)
        expect(divide(ROUNDING_MODE.DIRECTED_TOWARDS_NEGATIVE_INFINITY, 0n, 10n)).toBe(0n)
        expect(divide(ROUNDING_MODE.DIRECTED_TOWARDS_NEGATIVE_INFINITY, -2n, 10n)).toBe(-1n)
        expect(divide(ROUNDING_MODE.DIRECTED_TOWARDS_NEGATIVE_INFINITY, -5n, 10n)).toBe(-1n)
        expect(divide(ROUNDING_MODE.DIRECTED_TOWARDS_NEGATIVE_INFINITY, -8n, 10n)).toBe(-1n)
        expect(divide(ROUNDING_MODE.DIRECTED_TOWARDS_NEGATIVE_INFINITY, -10n, 10n)).toBe(-1n)
        expect(divide(ROUNDING_MODE.DIRECTED_TOWARDS_NEGATIVE_INFINITY, -12n, 10n)).toBe(-2n)
        expect(divide(ROUNDING_MODE.DIRECTED_TOWARDS_NEGATIVE_INFINITY, -15n, 10n)).toBe(-2n)
        expect(divide(ROUNDING_MODE.DIRECTED_TOWARDS_NEGATIVE_INFINITY, -18n, 10n)).toBe(-2n)
      })

      it('works on negatives', () => {
        expect(divide(ROUNDING_MODE.DIRECTED_TOWARDS_NEGATIVE_INFINITY, -18n, -10n)).toBe(1n)
        expect(divide(ROUNDING_MODE.DIRECTED_TOWARDS_NEGATIVE_INFINITY, -15n, -10n)).toBe(1n)
        expect(divide(ROUNDING_MODE.DIRECTED_TOWARDS_NEGATIVE_INFINITY, -12n, -10n)).toBe(1n)
        expect(divide(ROUNDING_MODE.DIRECTED_TOWARDS_NEGATIVE_INFINITY, -10n, -10n)).toBe(1n)
        expect(divide(ROUNDING_MODE.DIRECTED_TOWARDS_NEGATIVE_INFINITY, -8n, -10n)).toBe(0n)
        expect(divide(ROUNDING_MODE.DIRECTED_TOWARDS_NEGATIVE_INFINITY, -5n, -10n)).toBe(0n)
        expect(divide(ROUNDING_MODE.DIRECTED_TOWARDS_NEGATIVE_INFINITY, -2n, -10n)).toBe(0n)
        expect(divide(ROUNDING_MODE.DIRECTED_TOWARDS_NEGATIVE_INFINITY, 0n, -10n)).toBe(0n)
        expect(divide(ROUNDING_MODE.DIRECTED_TOWARDS_NEGATIVE_INFINITY, 2n, -10n)).toBe(-1n)
        expect(divide(ROUNDING_MODE.DIRECTED_TOWARDS_NEGATIVE_INFINITY, 5n, -10n)).toBe(-1n)
        expect(divide(ROUNDING_MODE.DIRECTED_TOWARDS_NEGATIVE_INFINITY, 8n, -10n)).toBe(-1n)
        expect(divide(ROUNDING_MODE.DIRECTED_TOWARDS_NEGATIVE_INFINITY, 10n, -10n)).toBe(-1n)
        expect(divide(ROUNDING_MODE.DIRECTED_TOWARDS_NEGATIVE_INFINITY, 12n, -10n)).toBe(-2n)
        expect(divide(ROUNDING_MODE.DIRECTED_TOWARDS_NEGATIVE_INFINITY, 15n, -10n)).toBe(-2n)
        expect(divide(ROUNDING_MODE.DIRECTED_TOWARDS_NEGATIVE_INFINITY, 18n, -10n)).toBe(-2n)
      })
    })

    describe('towards positive infinity', () => {
      it('works', () => {
        expect(divide(ROUNDING_MODE.DIRECTED_TOWARDS_POSITIVE_INFINITY, 18n, 10n)).toBe(2n)
        expect(divide(ROUNDING_MODE.DIRECTED_TOWARDS_POSITIVE_INFINITY, 15n, 10n)).toBe(2n)
        expect(divide(ROUNDING_MODE.DIRECTED_TOWARDS_POSITIVE_INFINITY, 12n, 10n)).toBe(2n)
        expect(divide(ROUNDING_MODE.DIRECTED_TOWARDS_POSITIVE_INFINITY, 10n, 10n)).toBe(1n)
        expect(divide(ROUNDING_MODE.DIRECTED_TOWARDS_POSITIVE_INFINITY, 8n, 10n)).toBe(1n)
        expect(divide(ROUNDING_MODE.DIRECTED_TOWARDS_POSITIVE_INFINITY, 5n, 10n)).toBe(1n)
        expect(divide(ROUNDING_MODE.DIRECTED_TOWARDS_POSITIVE_INFINITY, 2n, 10n)).toBe(1n)
        expect(divide(ROUNDING_MODE.DIRECTED_TOWARDS_POSITIVE_INFINITY, 0n, 10n)).toBe(0n)
        expect(divide(ROUNDING_MODE.DIRECTED_TOWARDS_POSITIVE_INFINITY, -2n, 10n)).toBe(0n)
        expect(divide(ROUNDING_MODE.DIRECTED_TOWARDS_POSITIVE_INFINITY, -5n, 10n)).toBe(0n)
        expect(divide(ROUNDING_MODE.DIRECTED_TOWARDS_POSITIVE_INFINITY, -8n, 10n)).toBe(0n)
        expect(divide(ROUNDING_MODE.DIRECTED_TOWARDS_POSITIVE_INFINITY, -10n, 10n)).toBe(-1n)
        expect(divide(ROUNDING_MODE.DIRECTED_TOWARDS_POSITIVE_INFINITY, -12n, 10n)).toBe(-1n)
        expect(divide(ROUNDING_MODE.DIRECTED_TOWARDS_POSITIVE_INFINITY, -15n, 10n)).toBe(-1n)
        expect(divide(ROUNDING_MODE.DIRECTED_TOWARDS_POSITIVE_INFINITY, -18n, 10n)).toBe(-1n)
      })

      it('works on negatives', () => {
        expect(divide(ROUNDING_MODE.DIRECTED_TOWARDS_POSITIVE_INFINITY, -18n, -10n)).toBe(2n)
        expect(divide(ROUNDING_MODE.DIRECTED_TOWARDS_POSITIVE_INFINITY, -15n, -10n)).toBe(2n)
        expect(divide(ROUNDING_MODE.DIRECTED_TOWARDS_POSITIVE_INFINITY, -12n, -10n)).toBe(2n)
        expect(divide(ROUNDING_MODE.DIRECTED_TOWARDS_POSITIVE_INFINITY, -10n, -10n)).toBe(1n)
        expect(divide(ROUNDING_MODE.DIRECTED_TOWARDS_POSITIVE_INFINITY, -8n, -10n)).toBe(1n)
        expect(divide(ROUNDING_MODE.DIRECTED_TOWARDS_POSITIVE_INFINITY, -5n, -10n)).toBe(1n)
        expect(divide(ROUNDING_MODE.DIRECTED_TOWARDS_POSITIVE_INFINITY, -2n, -10n)).toBe(1n)
        expect(divide(ROUNDING_MODE.DIRECTED_TOWARDS_POSITIVE_INFINITY, 0n, -10n)).toBe(0n)
        expect(divide(ROUNDING_MODE.DIRECTED_TOWARDS_POSITIVE_INFINITY, 2n, -10n)).toBe(0n)
        expect(divide(ROUNDING_MODE.DIRECTED_TOWARDS_POSITIVE_INFINITY, 5n, -10n)).toBe(0n)
        expect(divide(ROUNDING_MODE.DIRECTED_TOWARDS_POSITIVE_INFINITY, 8n, -10n)).toBe(0n)
        expect(divide(ROUNDING_MODE.DIRECTED_TOWARDS_POSITIVE_INFINITY, 10n, -10n)).toBe(-1n)
        expect(divide(ROUNDING_MODE.DIRECTED_TOWARDS_POSITIVE_INFINITY, 12n, -10n)).toBe(-1n)
        expect(divide(ROUNDING_MODE.DIRECTED_TOWARDS_POSITIVE_INFINITY, 15n, -10n)).toBe(-1n)
        expect(divide(ROUNDING_MODE.DIRECTED_TOWARDS_POSITIVE_INFINITY, 18n, -10n)).toBe(-1n)
      })
    })
  })

  describe('to nearest', () => {
    describe('half throws', () => {
      it('works', () => {
        expect(divide(ROUNDING_MODE.NEAREST_HALF_THROW, 18n, 10n)).toBe(2n)
        expect(() => divide(ROUNDING_MODE.NEAREST_HALF_THROW, 15n, 10n)).toThrowError()
        expect(divide(ROUNDING_MODE.NEAREST_HALF_THROW, 12n, 10n)).toBe(1n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_THROW, 10n, 10n)).toBe(1n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_THROW, 8n, 10n)).toBe(1n)
        expect(() => divide(ROUNDING_MODE.NEAREST_HALF_THROW, 5n, 10n)).toThrowError()
        expect(divide(ROUNDING_MODE.NEAREST_HALF_THROW, 2n, 10n)).toBe(0n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_THROW, 0n, 10n)).toBe(0n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_THROW, -2n, 10n)).toBe(0n)
        expect(() => divide(ROUNDING_MODE.NEAREST_HALF_THROW, -5n, 10n)).toThrowError()
        expect(divide(ROUNDING_MODE.NEAREST_HALF_THROW, -8n, 10n)).toBe(-1n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_THROW, -10n, 10n)).toBe(-1n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_THROW, -12n, 10n)).toBe(-1n)
        expect(() => divide(ROUNDING_MODE.NEAREST_HALF_THROW, -15n, 10n)).toThrowError()
        expect(divide(ROUNDING_MODE.NEAREST_HALF_THROW, -18n, 10n)).toBe(-2n)
      })

      it('works on negatives', () => {
        expect(divide(ROUNDING_MODE.NEAREST_HALF_THROW, -18n, -10n)).toBe(2n)
        expect(() => divide(ROUNDING_MODE.NEAREST_HALF_THROW, -15n, -10n)).toThrowError()
        expect(divide(ROUNDING_MODE.NEAREST_HALF_THROW, -12n, -10n)).toBe(1n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_THROW, -10n, -10n)).toBe(1n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_THROW, -8n, -10n)).toBe(1n)
        expect(() => divide(ROUNDING_MODE.NEAREST_HALF_THROW, -5n, -10n)).toThrowError()
        expect(divide(ROUNDING_MODE.NEAREST_HALF_THROW, -2n, -10n)).toBe(0n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_THROW, 0n, -10n)).toBe(0n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_THROW, 2n, -10n)).toBe(0n)
        expect(() => divide(ROUNDING_MODE.NEAREST_HALF_THROW, 5n, -10n)).toThrowError()
        expect(divide(ROUNDING_MODE.NEAREST_HALF_THROW, 8n, -10n)).toBe(-1n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_THROW, 10n, -10n)).toBe(-1n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_THROW, 12n, -10n)).toBe(-1n)
        expect(() => divide(ROUNDING_MODE.NEAREST_HALF_THROW, 15n, -10n)).toThrowError()
        expect(divide(ROUNDING_MODE.NEAREST_HALF_THROW, 18n, -10n)).toBe(-2n)
      })
    })

    describe('half towards zero', () => {
      it('works', () => {
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TOWARDS_ZERO, 18n, 10n)).toBe(2n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TOWARDS_ZERO, 15n, 10n)).toBe(1n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TOWARDS_ZERO, 12n, 10n)).toBe(1n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TOWARDS_ZERO, 10n, 10n)).toBe(1n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TOWARDS_ZERO, 8n, 10n)).toBe(1n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TOWARDS_ZERO, 5n, 10n)).toBe(0n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TOWARDS_ZERO, 2n, 10n)).toBe(0n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TOWARDS_ZERO, 0n, 10n)).toBe(0n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TOWARDS_ZERO, -2n, 10n)).toBe(0n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TOWARDS_ZERO, -5n, 10n)).toBe(0n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TOWARDS_ZERO, -8n, 10n)).toBe(-1n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TOWARDS_ZERO, -10n, 10n)).toBe(-1n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TOWARDS_ZERO, -12n, 10n)).toBe(-1n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TOWARDS_ZERO, -15n, 10n)).toBe(-1n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TOWARDS_ZERO, -18n, 10n)).toBe(-2n)
      })

      it('works on negatives', () => {
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TOWARDS_ZERO, -18n, -10n)).toBe(2n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TOWARDS_ZERO, -15n, -10n)).toBe(1n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TOWARDS_ZERO, -12n, -10n)).toBe(1n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TOWARDS_ZERO, -10n, -10n)).toBe(1n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TOWARDS_ZERO, -8n, -10n)).toBe(1n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TOWARDS_ZERO, -5n, -10n)).toBe(0n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TOWARDS_ZERO, -2n, -10n)).toBe(0n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TOWARDS_ZERO, 0n, -10n)).toBe(0n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TOWARDS_ZERO, 2n, -10n)).toBe(0n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TOWARDS_ZERO, 5n, -10n)).toBe(0n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TOWARDS_ZERO, 8n, -10n)).toBe(-1n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TOWARDS_ZERO, 10n, -10n)).toBe(-1n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TOWARDS_ZERO, 12n, -10n)).toBe(-1n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TOWARDS_ZERO, 15n, -10n)).toBe(-1n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TOWARDS_ZERO, 18n, -10n)).toBe(-2n)
      })
    })

    describe('half away from zero', () => {
      it('works', () => {
        expect(divide(ROUNDING_MODE.NEAREST_HALF_AWAY_FROM_ZERO, 18n, 10n)).toBe(2n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_AWAY_FROM_ZERO, 15n, 10n)).toBe(2n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_AWAY_FROM_ZERO, 12n, 10n)).toBe(1n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_AWAY_FROM_ZERO, 10n, 10n)).toBe(1n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_AWAY_FROM_ZERO, 8n, 10n)).toBe(1n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_AWAY_FROM_ZERO, 5n, 10n)).toBe(1n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_AWAY_FROM_ZERO, 2n, 10n)).toBe(0n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_AWAY_FROM_ZERO, 0n, 10n)).toBe(0n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_AWAY_FROM_ZERO, -2n, 10n)).toBe(0n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_AWAY_FROM_ZERO, -5n, 10n)).toBe(-1n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_AWAY_FROM_ZERO, -8n, 10n)).toBe(-1n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_AWAY_FROM_ZERO, -10n, 10n)).toBe(-1n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_AWAY_FROM_ZERO, -12n, 10n)).toBe(-1n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_AWAY_FROM_ZERO, -15n, 10n)).toBe(-2n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_AWAY_FROM_ZERO, -18n, 10n)).toBe(-2n)
      })

      it('works on negatives', () => {
        expect(divide(ROUNDING_MODE.NEAREST_HALF_AWAY_FROM_ZERO, -18n, -10n)).toBe(2n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_AWAY_FROM_ZERO, -15n, -10n)).toBe(2n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_AWAY_FROM_ZERO, -12n, -10n)).toBe(1n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_AWAY_FROM_ZERO, -10n, -10n)).toBe(1n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_AWAY_FROM_ZERO, -8n, -10n)).toBe(1n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_AWAY_FROM_ZERO, -5n, -10n)).toBe(1n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_AWAY_FROM_ZERO, -2n, -10n)).toBe(0n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_AWAY_FROM_ZERO, 0n, -10n)).toBe(0n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_AWAY_FROM_ZERO, 2n, -10n)).toBe(0n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_AWAY_FROM_ZERO, 5n, -10n)).toBe(-1n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_AWAY_FROM_ZERO, 8n, -10n)).toBe(-1n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_AWAY_FROM_ZERO, 10n, -10n)).toBe(-1n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_AWAY_FROM_ZERO, 12n, -10n)).toBe(-1n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_AWAY_FROM_ZERO, 15n, -10n)).toBe(-2n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_AWAY_FROM_ZERO, 18n, -10n)).toBe(-2n)
      })
    })

    describe('half towards negative infinity', () => {
      it('works', () => {
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TOWARDS_NEGATIVE_INFINITY, 18n, 10n)).toBe(2n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TOWARDS_NEGATIVE_INFINITY, 15n, 10n)).toBe(1n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TOWARDS_NEGATIVE_INFINITY, 12n, 10n)).toBe(1n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TOWARDS_NEGATIVE_INFINITY, 10n, 10n)).toBe(1n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TOWARDS_NEGATIVE_INFINITY, 8n, 10n)).toBe(1n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TOWARDS_NEGATIVE_INFINITY, 5n, 10n)).toBe(0n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TOWARDS_NEGATIVE_INFINITY, 2n, 10n)).toBe(0n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TOWARDS_NEGATIVE_INFINITY, 0n, 10n)).toBe(0n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TOWARDS_NEGATIVE_INFINITY, -2n, 10n)).toBe(0n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TOWARDS_NEGATIVE_INFINITY, -5n, 10n)).toBe(-1n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TOWARDS_NEGATIVE_INFINITY, -8n, 10n)).toBe(-1n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TOWARDS_NEGATIVE_INFINITY, -10n, 10n)).toBe(-1n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TOWARDS_NEGATIVE_INFINITY, -12n, 10n)).toBe(-1n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TOWARDS_NEGATIVE_INFINITY, -15n, 10n)).toBe(-2n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TOWARDS_NEGATIVE_INFINITY, -18n, 10n)).toBe(-2n)
      })

      it('works on negatives', () => {
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TOWARDS_NEGATIVE_INFINITY, -18n, -10n)).toBe(2n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TOWARDS_NEGATIVE_INFINITY, -15n, -10n)).toBe(1n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TOWARDS_NEGATIVE_INFINITY, -12n, -10n)).toBe(1n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TOWARDS_NEGATIVE_INFINITY, -10n, -10n)).toBe(1n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TOWARDS_NEGATIVE_INFINITY, -8n, -10n)).toBe(1n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TOWARDS_NEGATIVE_INFINITY, -5n, -10n)).toBe(0n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TOWARDS_NEGATIVE_INFINITY, -2n, -10n)).toBe(0n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TOWARDS_NEGATIVE_INFINITY, 0n, -10n)).toBe(0n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TOWARDS_NEGATIVE_INFINITY, 2n, -10n)).toBe(0n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TOWARDS_NEGATIVE_INFINITY, 5n, -10n)).toBe(-1n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TOWARDS_NEGATIVE_INFINITY, 8n, -10n)).toBe(-1n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TOWARDS_NEGATIVE_INFINITY, 10n, -10n)).toBe(-1n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TOWARDS_NEGATIVE_INFINITY, 12n, -10n)).toBe(-1n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TOWARDS_NEGATIVE_INFINITY, 15n, -10n)).toBe(-2n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TOWARDS_NEGATIVE_INFINITY, 18n, -10n)).toBe(-2n)
      })
    })

    describe('half towards positive infinity', () => {
      it('works', () => {
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TOWARDS_POSITIVE_INFINITY, 18n, 10n)).toBe(2n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TOWARDS_POSITIVE_INFINITY, 15n, 10n)).toBe(2n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TOWARDS_POSITIVE_INFINITY, 12n, 10n)).toBe(1n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TOWARDS_POSITIVE_INFINITY, 10n, 10n)).toBe(1n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TOWARDS_POSITIVE_INFINITY, 8n, 10n)).toBe(1n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TOWARDS_POSITIVE_INFINITY, 5n, 10n)).toBe(1n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TOWARDS_POSITIVE_INFINITY, 2n, 10n)).toBe(0n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TOWARDS_POSITIVE_INFINITY, 0n, 10n)).toBe(0n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TOWARDS_POSITIVE_INFINITY, -2n, 10n)).toBe(0n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TOWARDS_POSITIVE_INFINITY, -5n, 10n)).toBe(0n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TOWARDS_POSITIVE_INFINITY, -8n, 10n)).toBe(-1n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TOWARDS_POSITIVE_INFINITY, -10n, 10n)).toBe(-1n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TOWARDS_POSITIVE_INFINITY, -12n, 10n)).toBe(-1n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TOWARDS_POSITIVE_INFINITY, -15n, 10n)).toBe(-1n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TOWARDS_POSITIVE_INFINITY, -18n, 10n)).toBe(-2n)
      })

      it('works on negatives', () => {
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TOWARDS_POSITIVE_INFINITY, -18n, -10n)).toBe(2n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TOWARDS_POSITIVE_INFINITY, -15n, -10n)).toBe(2n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TOWARDS_POSITIVE_INFINITY, -12n, -10n)).toBe(1n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TOWARDS_POSITIVE_INFINITY, -10n, -10n)).toBe(1n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TOWARDS_POSITIVE_INFINITY, -8n, -10n)).toBe(1n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TOWARDS_POSITIVE_INFINITY, -5n, -10n)).toBe(1n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TOWARDS_POSITIVE_INFINITY, -2n, -10n)).toBe(0n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TOWARDS_POSITIVE_INFINITY, 0n, -10n)).toBe(0n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TOWARDS_POSITIVE_INFINITY, 2n, -10n)).toBe(0n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TOWARDS_POSITIVE_INFINITY, 5n, -10n)).toBe(0n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TOWARDS_POSITIVE_INFINITY, 8n, -10n)).toBe(-1n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TOWARDS_POSITIVE_INFINITY, 10n, -10n)).toBe(-1n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TOWARDS_POSITIVE_INFINITY, 12n, -10n)).toBe(-1n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TOWARDS_POSITIVE_INFINITY, 15n, -10n)).toBe(-1n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TOWARDS_POSITIVE_INFINITY, 18n, -10n)).toBe(-2n)
      })
    })

    describe('half to even', () => {
      it('works', () => {
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TO_EVEN, 18n, 10n)).toBe(2n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TO_EVEN, 15n, 10n)).toBe(2n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TO_EVEN, 12n, 10n)).toBe(1n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TO_EVEN, 10n, 10n)).toBe(1n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TO_EVEN, 8n, 10n)).toBe(1n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TO_EVEN, 5n, 10n)).toBe(0n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TO_EVEN, 2n, 10n)).toBe(0n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TO_EVEN, 0n, 10n)).toBe(0n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TO_EVEN, -2n, 10n)).toBe(0n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TO_EVEN, -5n, 10n)).toBe(0n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TO_EVEN, -8n, 10n)).toBe(-1n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TO_EVEN, -10n, 10n)).toBe(-1n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TO_EVEN, -12n, 10n)).toBe(-1n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TO_EVEN, -15n, 10n)).toBe(-2n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TO_EVEN, -18n, 10n)).toBe(-2n)
      })

      it('works on negatives', () => {
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TO_EVEN, -18n, -10n)).toBe(2n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TO_EVEN, -15n, -10n)).toBe(2n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TO_EVEN, -12n, -10n)).toBe(1n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TO_EVEN, -10n, -10n)).toBe(1n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TO_EVEN, -8n, -10n)).toBe(1n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TO_EVEN, -5n, -10n)).toBe(0n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TO_EVEN, -2n, -10n)).toBe(0n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TO_EVEN, 0n, -10n)).toBe(0n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TO_EVEN, 2n, -10n)).toBe(0n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TO_EVEN, 5n, -10n)).toBe(0n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TO_EVEN, 8n, -10n)).toBe(-1n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TO_EVEN, 10n, -10n)).toBe(-1n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TO_EVEN, 12n, -10n)).toBe(-1n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TO_EVEN, 15n, -10n)).toBe(-2n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TO_EVEN, 18n, -10n)).toBe(-2n)
      })
    })

    describe('half to odd', () => {
      it('works', () => {
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TO_ODD, 18n, 10n)).toBe(2n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TO_ODD, 15n, 10n)).toBe(1n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TO_ODD, 12n, 10n)).toBe(1n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TO_ODD, 10n, 10n)).toBe(1n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TO_ODD, 8n, 10n)).toBe(1n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TO_ODD, 5n, 10n)).toBe(1n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TO_ODD, 2n, 10n)).toBe(0n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TO_ODD, 0n, 10n)).toBe(0n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TO_ODD, -2n, 10n)).toBe(0n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TO_ODD, -5n, 10n)).toBe(-1n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TO_ODD, -8n, 10n)).toBe(-1n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TO_ODD, -10n, 10n)).toBe(-1n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TO_ODD, -12n, 10n)).toBe(-1n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TO_ODD, -15n, 10n)).toBe(-1n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TO_ODD, -18n, 10n)).toBe(-2n)
      })

      it('works on negatives', () => {
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TO_ODD, -18n, -10n)).toBe(2n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TO_ODD, -15n, -10n)).toBe(1n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TO_ODD, -12n, -10n)).toBe(1n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TO_ODD, -10n, -10n)).toBe(1n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TO_ODD, -8n, -10n)).toBe(1n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TO_ODD, -5n, -10n)).toBe(1n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TO_ODD, -2n, -10n)).toBe(0n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TO_ODD, 0n, -10n)).toBe(0n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TO_ODD, 2n, -10n)).toBe(0n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TO_ODD, 5n, -10n)).toBe(-1n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TO_ODD, 8n, -10n)).toBe(-1n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TO_ODD, 10n, -10n)).toBe(-1n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TO_ODD, 12n, -10n)).toBe(-1n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TO_ODD, 15n, -10n)).toBe(-1n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_TO_ODD, 18n, -10n)).toBe(-2n)
      })
    })

    describe('half alternates up and down', () => {
      it('works', () => {
        expect(divide(ROUNDING_MODE.NEAREST_HALF_ALTERNATE, 18n, 10n)).toBe(2n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_ALTERNATE, 15n, 10n)).toBe(2n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_ALTERNATE, 15n, 10n)).toBe(1n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_ALTERNATE, 12n, 10n)).toBe(1n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_ALTERNATE, 10n, 10n)).toBe(1n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_ALTERNATE, 8n, 10n)).toBe(1n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_ALTERNATE, 5n, 10n)).toBe(1n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_ALTERNATE, 5n, 10n)).toBe(0n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_ALTERNATE, 2n, 10n)).toBe(0n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_ALTERNATE, 0n, 10n)).toBe(0n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_ALTERNATE, -2n, 10n)).toBe(0n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_ALTERNATE, -5n, 10n)).toBe(-1n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_ALTERNATE, -5n, 10n)).toBe(0n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_ALTERNATE, -8n, 10n)).toBe(-1n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_ALTERNATE, -10n, 10n)).toBe(-1n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_ALTERNATE, -12n, 10n)).toBe(-1n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_ALTERNATE, -15n, 10n)).toBe(-2n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_ALTERNATE, -15n, 10n)).toBe(-1n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_ALTERNATE, -18n, 10n)).toBe(-2n)
      })

      it('works on negatives', () => {
        expect(divide(ROUNDING_MODE.NEAREST_HALF_ALTERNATE, -18n, -10n)).toBe(2n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_ALTERNATE, -15n, -10n)).toBe(2n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_ALTERNATE, -15n, -10n)).toBe(1n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_ALTERNATE, -12n, -10n)).toBe(1n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_ALTERNATE, -10n, -10n)).toBe(1n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_ALTERNATE, -8n, -10n)).toBe(1n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_ALTERNATE, -5n, -10n)).toBe(1n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_ALTERNATE, -5n, -10n)).toBe(0n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_ALTERNATE, -2n, -10n)).toBe(0n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_ALTERNATE, 0n, -10n)).toBe(0n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_ALTERNATE, 2n, -10n)).toBe(0n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_ALTERNATE, 5n, -10n)).toBe(-1n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_ALTERNATE, 5n, -10n)).toBe(0n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_ALTERNATE, 8n, -10n)).toBe(-1n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_ALTERNATE, 10n, -10n)).toBe(-1n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_ALTERNATE, 12n, -10n)).toBe(-1n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_ALTERNATE, 15n, -10n)).toBe(-2n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_ALTERNATE, 15n, -10n)).toBe(-1n)
        expect(divide(ROUNDING_MODE.NEAREST_HALF_ALTERNATE, 18n, -10n)).toBe(-2n)
      })
    })

    describe('half random', () => {
      it('"works"', () => {
        // Ugh whatever
        const buckets = { 1: 0, 2: 0 }
        for (let i = 0; i < 1000; i++) {
          buckets[String(divide(ROUNDING_MODE.NEAREST_HALF_RANDOM, 15n, 10n))]++
        }
        expect(buckets[1] > 450 && buckets[1] < 550).toBe(true)
        expect(buckets[2] > 450 && buckets[2] < 550).toBe(true)
      })
    })
  })

  describe('random', () => {
    describe('stochastic', () => {
      it('"works"', () => {
        // Submit a PR if you have a half-decent idea of how to unit this nonsense
        const buckets = { 1: 0, 2: 0 }
        for (let i = 0; i < 1000; i++) {
          buckets[String(divide(ROUNDING_MODE.STOCHASTIC, -16n, -10n))]++
        }
        expect(buckets[1] > 350 && buckets[1] < 450).toBe(true)
        expect(buckets[2] > 550 && buckets[2] < 650).toBe(true)
      })
    })
  })
})
